
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>detectOtherSymbols</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-04-02"><meta name="DC.source" content="detectOtherSymbols.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">%-------------------------------------------------------------------------</span>
<span class="comment">% Function name:    detectOtherSymbols</span>
<span class="comment">% Input arg(s):     non-note section, staff space/line heights, rest/acci-</span>
<span class="comment">%                   dental/dot/tie/slur dataset</span>
<span class="comment">% Outputs arg(s):   other symbols and ledger line locations</span>
<span class="comment">% Description:      Detects relevant non-note symbols such as rests, aug-</span>
<span class="comment">%                   mentation dots, among others</span>
<span class="comment">%-------------------------------------------------------------------------</span>
<span class="keyword">function</span> [otherSyms, ledgerLineLocs] = detectOtherSymbols(section, <span class="keyword">...</span>
    spaceHeight, lineHeight, staffLines, combinedSyms, dotSyms, <span class="keyword">...</span>
    tieSlurSyms, debug)

    <span class="comment">% Calculate the height of the entire staff</span>
    staffHeight = max(staffLines) - min(staffLines);
    <span class="comment">% Preliminary barline detection: Removal of lines that are almost the</span>
    <span class="comment">% same height as the staff</span>
    tempErode = imerode(~section,strel(<span class="string">'rectangle'</span>, [staffHeight-5, 2]));
    tempDilate = imdilate(tempErode,strel(<span class="string">'rectangle'</span>, [staffHeight-5,<span class="keyword">...</span>
        2]));
    noBarLines = xor(section,tempDilate);
    barSection = ~tempDilate;

    <span class="comment">%---------------------------------------------------------------</span>
    <span class="comment">% First pass: Detecting symbols after vertical connection</span>
    <span class="comment">% - Before template matching, potential symbols are connected</span>
    <span class="comment">%   vertically to ensure that symbols with multiple components</span>
    <span class="comment">%   (such as fermata) will be detected properly</span>
    <span class="comment">% - All but the tie/slur dataset will be used</span>
    <span class="comment">%---------------------------------------------------------------</span>
    <span class="comment">% Connect symbols with a line of lenght spaceHeight</span>
    tempClose = imclose(~noBarLines, strel(<span class="string">'line'</span>, spaceHeight, 90));
    stats = regionprops(tempClose, <span class="string">'BoundingBox'</span>, <span class="string">'Area'</span>);
    <span class="comment">% Call vertical symbols detection function</span>
    [otherSyms1, tempImg1] = otherSymsVert(section, stats, spaceHeight, <span class="keyword">...</span>
        combinedSyms, dotSyms, debug);

    <span class="comment">% Remove symbols that have been already detected from the non-barline</span>
    <span class="comment">% image</span>
    imgNoSyms1 = ~xor(noBarLines,tempImg1);

    <span class="comment">% Perform run-length encoding on the image with only barlines to</span>
    <span class="comment">% get maximum barline width; if there are no barlines, the default</span>
    <span class="comment">% width is three times the lineHeight</span>
    len = encodeRL(barSection');
    barWidth = len(1:2:end);
    barWidth = max(barWidth(barWidth ~= 0));
    <span class="keyword">if</span>(isempty(barWidth))
        barWidth = 3*lineHeight;
    <span class="keyword">end</span>

    <span class="comment">%---------------------------------------------------------------</span>
    <span class="comment">% Second pass: Detection of ties/slurs and other symbols missed</span>
    <span class="comment">%     by the first pass</span>
    <span class="comment">%---------------------------------------------------------------</span>
    <span class="comment">% Temporarily connect the symbols horizontally for reference</span>
    tempClose2 = imclose(~imgNoSyms1, strel(<span class="string">'line'</span>, barWidth+2, 0));
    <span class="comment">% Get and add the gaps that were produced by the barline removal</span>
    barGap = and(~barSection, tempClose2);
    <span class="comment">% Connect the symbols using the generated gaps</span>
    tempClose2 = or(~imgNoSyms1, barGap);
    stats2 = regionprops(tempClose2, <span class="string">'BoundingBox'</span>, <span class="string">'Area'</span>);
    <span class="comment">% Call horizontal symbols detection function</span>
    [otherSyms2, tempImg2] = otherSymsHorz(section, stats2, <span class="keyword">...</span>
        spaceHeight, combinedSyms, dotSyms, tieSlurSyms, debug);

    <span class="comment">% Remove symbols that have already been detected from the non-barline</span>
    <span class="comment">% image, leaving potential ledger lines</span>
    ledgerBarline = xor(imgNoSyms1,tempImg2);
    cc = bwconncomp(ledgerBarline);
    ledgerStats = regionprops(cc, <span class="string">'Area'</span>);
    <span class="comment">% Remove bigger components that might be treated as ledger lines</span>
    <span class="comment">% such as dynamic markings</span>
    idx = find([ledgerStats.Area] &lt;= (20*spaceHeight));
    ledgerBarline2 = ~ismember(labelmatrix(cc), idx);

    <span class="comment">% Extract ledger line locations similar to the note detections</span>
    ledgerLines = imclose(ledgerBarline2, strel(<span class="string">'line'</span>, <span class="keyword">...</span>
        floor(spaceHeight * 2), 0));
    lineExt = imdilate(~ledgerLines, strel(<span class="string">'line'</span>, <span class="keyword">...</span>
        2*size(section,2), 0));
    ledgerLineLocs = find(sum(lineExt, 2) ~= 0);


    <span class="comment">%---------------------------------------------------------------</span>
    <span class="comment">% Third pass: Detection of barlines (single/double)</span>
    <span class="comment">%---------------------------------------------------------------</span>
    <span class="comment">% Temporarily connect lines horizontally for bounding box calculation</span>
    barClose = imclose(~barSection, strel(<span class="string">'line'</span>, spaceHeight, 0));
    barStats = regionprops(barClose, <span class="string">'BoundingBox'</span>);

    symbol = {};
    loc = {};
    category = {};
    type = {};
    value = {};
    symIdx = {};
    symCount = 1;
    <span class="keyword">for</span> jjj = 1:numel(barStats)
        <span class="comment">% Extract bounding box parameters</span>
        tempImg3 = ones(size(section));
        z3 = barStats(jjj).BoundingBox;
        h3 = ceil(z3(2))+z3(4);
        w3 = ceil(z3(1))+z3(3);
        boxHeight3 = ceil(z3(2)):h3;
        boxWidth3 = ceil(z3(1)):w3;

        <span class="comment">% Copy section based on bounding box parametters</span>
        tempImg3(boxHeight3, boxWidth3) = section(boxHeight3, boxWidth3);
        barStats2 = regionprops(~tempImg3);
        barlineCount = numel(barStats2);

        <span class="comment">% Determine barline type based on the number of vertical lines</span>
        <span class="keyword">if</span> (barlineCount == 1 || barlineCount == 2)
            <span class="keyword">if</span> (barlineCount == 1)
                barLineType = <span class="string">'single'</span>;
            <span class="keyword">else</span>
                barLineType = <span class="string">'double'</span>;
            <span class="keyword">end</span>

            <span class="comment">% Each barline's parameters are saved</span>
            symbol{symCount} = tempImg3(boxHeight3, boxWidth3);
            loc(symCount) = {[ceil(z3(2)) h3 ceil(z3(1)) w3]};
            category(symCount) = {<span class="string">'barline'</span>};
            type(symCount) = {barLineType};
            value(symCount) = {0};
            symIdx(symCount) = {ceil(z3(1))};
            symCount = symCount + 1;

        <span class="keyword">end</span>
        <span class="keyword">if</span> (debug == 1)
            rectangle(<span class="string">'Position'</span>,barStats(jjj).BoundingBox, <span class="keyword">...</span>
                <span class="string">'EdgeColor'</span>,<span class="string">'g'</span>, <span class="string">'LineWidth'</span>,2);
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Combine parameters for complete non-note symbol definitions</span>
    <span class="keyword">if</span> (~isempty(symbol))
        otherSymsTmp = [symbol', loc', category', type', value', symIdx'];
        <span class="comment">% Sort symbols based on x-axis locations</span>
        otherSyms = sortrows([otherSyms1; otherSyms2; otherSymsTmp],6);
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput error">Not enough input arguments.

Error in detectOtherSymbols (line 14)
    staffHeight = max(staffLines) - min(staffLines);
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% Function name:    detectOtherSymbols
% Input arg(s):     non-note section, staff space/line heights, rest/acci-
%                   dental/dot/tie/slur dataset
% Outputs arg(s):   other symbols and ledger line locations
% Description:      Detects relevant non-note symbols such as rests, aug-
%                   mentation dots, among others
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
function [otherSyms, ledgerLineLocs] = detectOtherSymbols(section, ...
    spaceHeight, lineHeight, staffLines, combinedSyms, dotSyms, ...
    tieSlurSyms, debug)

    % Calculate the height of the entire staff
    staffHeight = max(staffLines) - min(staffLines);
    % Preliminary barline detection: Removal of lines that are almost the 
    % same height as the staff
    tempErode = imerode(~section,strel('rectangle', [staffHeight-5, 2]));
    tempDilate = imdilate(tempErode,strel('rectangle', [staffHeight-5,...
        2]));
    noBarLines = xor(section,tempDilate);
    barSection = ~tempDilate;

    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    % First pass: Detecting symbols after vertical connection
    % - Before template matching, potential symbols are connected
    %   vertically to ensure that symbols with multiple components
    %   (such as fermata) will be detected properly
    % - All but the tie/slur dataset will be used
    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    % Connect symbols with a line of lenght spaceHeight
    tempClose = imclose(~noBarLines, strel('line', spaceHeight, 90));
    stats = regionprops(tempClose, 'BoundingBox', 'Area');
    % Call vertical symbols detection function
    [otherSyms1, tempImg1] = otherSymsVert(section, stats, spaceHeight, ...
        combinedSyms, dotSyms, debug);

    % Remove symbols that have been already detected from the non-barline 
    % image
    imgNoSyms1 = ~xor(noBarLines,tempImg1);
    
    % Perform run-length encoding on the image with only barlines to 
    % get maximum barline width; if there are no barlines, the default
    % width is three times the lineHeight
    len = encodeRL(barSection');
    barWidth = len(1:2:end);
    barWidth = max(barWidth(barWidth ~= 0));    
    if(isempty(barWidth))
        barWidth = 3*lineHeight;        
    end
    
    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    % Second pass: Detection of ties/slurs and other symbols missed
    %     by the first pass
    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    % Temporarily connect the symbols horizontally for reference
    tempClose2 = imclose(~imgNoSyms1, strel('line', barWidth+2, 0));
    % Get and add the gaps that were produced by the barline removal
    barGap = and(~barSection, tempClose2);
    % Connect the symbols using the generated gaps 
    tempClose2 = or(~imgNoSyms1, barGap);
    stats2 = regionprops(tempClose2, 'BoundingBox', 'Area');
    % Call horizontal symbols detection function    
    [otherSyms2, tempImg2] = otherSymsHorz(section, stats2, ...
        spaceHeight, combinedSyms, dotSyms, tieSlurSyms, debug);

    % Remove symbols that have already been detected from the non-barline 
    % image, leaving potential ledger lines 
    ledgerBarline = xor(imgNoSyms1,tempImg2);
    cc = bwconncomp(ledgerBarline);
    ledgerStats = regionprops(cc, 'Area');
    % Remove bigger components that might be treated as ledger lines
    % such as dynamic markings
    idx = find([ledgerStats.Area] <= (20*spaceHeight));
    ledgerBarline2 = ~ismember(labelmatrix(cc), idx);

    % Extract ledger line locations similar to the note detections
    ledgerLines = imclose(ledgerBarline2, strel('line', ...
        floor(spaceHeight * 2), 0));
    lineExt = imdilate(~ledgerLines, strel('line', ...
        2*size(section,2), 0));
    ledgerLineLocs = find(sum(lineExt, 2) ~= 0);

    
    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    % Third pass: Detection of barlines (single/double)
    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
    % Temporarily connect lines horizontally for bounding box calculation
    barClose = imclose(~barSection, strel('line', spaceHeight, 0));
    barStats = regionprops(barClose, 'BoundingBox');

    symbol = {};
    loc = {};
    category = {};
    type = {};
    value = {}; 
    symIdx = {};
    symCount = 1;
    for jjj = 1:numel(barStats)
        % Extract bounding box parameters
        tempImg3 = ones(size(section));
        z3 = barStats(jjj).BoundingBox;
        h3 = ceil(z3(2))+z3(4);
        w3 = ceil(z3(1))+z3(3);
        boxHeight3 = ceil(z3(2)):h3;
        boxWidth3 = ceil(z3(1)):w3;

        % Copy section based on bounding box parametters
        tempImg3(boxHeight3, boxWidth3) = section(boxHeight3, boxWidth3);
        barStats2 = regionprops(~tempImg3);
        barlineCount = numel(barStats2);

        % Determine barline type based on the number of vertical lines
        if (barlineCount == 1 || barlineCount == 2) 
            if (barlineCount == 1)
                barLineType = 'single';
            else
                barLineType = 'double';
            end
            
            % Each barline's parameters are saved
            symbol{symCount} = tempImg3(boxHeight3, boxWidth3);
            loc(symCount) = {[ceil(z3(2)) h3 ceil(z3(1)) w3]};
            category(symCount) = {'barline'};
            type(symCount) = {barLineType};
            value(symCount) = {0};
            symIdx(symCount) = {ceil(z3(1))};
            symCount = symCount + 1;   

        end
        if (debug == 1)
            rectangle('Position',barStats(jjj).BoundingBox, ...
                'EdgeColor','g', 'LineWidth',2);
        end
    end
    
    % Combine parameters for complete non-note symbol definitions
    if (~isempty(symbol))
        otherSymsTmp = [symbol', loc', category', type', value', symIdx'];
        % Sort symbols based on x-axis locations
        otherSyms = sortrows([otherSyms1; otherSyms2; otherSymsTmp],6);
    end
end
##### SOURCE END #####
--></body></html>