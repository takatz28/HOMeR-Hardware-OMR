
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>detectUnbeamedNotes</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-04-02"><meta name="DC.source" content="detectUnbeamedNotes.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput"><span class="comment">%-------------------------------------------------------------------------</span>
<span class="comment">% Function name:    detectUnbeamedNotes</span>
<span class="comment">% Input arg(s):     unbeamed section, staff space/line heights, whole</span>
<span class="comment">%                   note dataset</span>
<span class="comment">% Outputs arg(s):   unbeamed notes and ledger line locations</span>
<span class="comment">% Description:      Detects single and chord unbeamed notes from whole</span>
<span class="comment">%                   to 64th</span>
<span class="comment">%-------------------------------------------------------------------------</span>
<span class="keyword">function</span> [unbeamedNotes, ledgerLineLocs] = detectUnbeamedNotes(<span class="keyword">...</span>
    section, spaceHeight, lineHeight, wholeNotes, debug)

    <span class="comment">% Extract ledger lines for subsequent pitch assignment</span>
    ledgerLines = imclose(section, strel(<span class="string">'rectangle'</span>, <span class="keyword">...</span>
        [2, floor(spaceHeight * 2)]));
    cc = bwconncomp(~ledgerLines);
    stats = regionprops(cc, <span class="string">'Area'</span>);
    <span class="comment">% Ensures that only ledger lines are being removed and not segments</span>
    <span class="comment">% of adjacent notes</span>
    idx = find([stats.Area] &lt;= 12*spaceHeight);
    ledgerLines = ismember(labelmatrix(cc), idx);
    <span class="comment">% Extends the ledger lines for location calculation</span>
    lineExt = imdilate(ledgerLines, strel(<span class="string">'line'</span>, <span class="keyword">...</span>
        2*size(section,2), 0));
    ledgerLineLocs = find(sum(lineExt, 2) ~= 0);

    <span class="comment">% If ledger lines exist in the section, they are to be removed before</span>
    <span class="comment">% detection</span>
    <span class="keyword">if</span>(~isempty(ledgerLineLocs))
        section = ledgerRemove(section, ledgerLineLocs);
    <span class="keyword">end</span>

    symbol = {};
    loc = {};
    category = {};
    type = {};
    value = {};
    symIdx = {};
    symCount = 1;

    <span class="comment">% Perform a small opening to ensure that note edges are connected</span>
    section = imopen(section, strel(<span class="string">'line'</span>, 3, 0));
    noteStats = regionprops(~section, <span class="string">'BoundingBox'</span>);
    <span class="comment">% Examine individual component</span>
    <span class="keyword">for</span> i = 1:numel(noteStats)
        <span class="comment">% Extract component boundaries</span>
        tempImg = ones(size(section));
        unbeamedNoteHeads = ones(size(section));
        z = noteStats(i).BoundingBox;
        h = ceil(z(2))+z(4);
        w = ceil(z(1))+z(3);
        boxHeight = ceil(z(2)):h-1;
        boxWidth = ceil(z(1)):w-1;
        <span class="comment">% Copy note in temporary holder</span>
        tempImg(boxHeight, boxWidth) = section(boxHeight, boxWidth);
<span class="comment">%         imshow(tempImg); pause;</span>
        <span class="comment">%--------------------------------------------------------</span>
        <span class="comment">% Stem detection: Determines if the symbol is either:</span>
        <span class="comment">% - (half-64th) note/chord         - whole note chords</span>
        <span class="comment">% - single whole notes</span>
        <span class="comment">%--------------------------------------------------------</span>
        <span class="comment">% Checks for (half-64th) notes/chords:</span>
        stemChecker = imerode(~tempImg, strel(<span class="string">'line'</span>, <span class="keyword">...</span>
            (3*spaceHeight + 2*lineHeight), 90));
        stemChecker = imdilate(stemChecker, strel(<span class="string">'line'</span>, <span class="keyword">...</span>
            (3*spaceHeight + 2*lineHeight), 90));
        stemStats = regionprops(stemChecker);
        <span class="comment">% Checks for (half-64th) chords that were missed by first check:</span>
        <span class="keyword">if</span> (numel(stemStats) &gt; 1)
            stemChecker = imopen(stemChecker, strel(<span class="string">'line'</span>, <span class="keyword">...</span>
                4.25*spaceHeight, 90));
            stemStats = regionprops(stemChecker);
        <span class="comment">% Checks for whole notes/chords:</span>
        <span class="keyword">elseif</span> (numel(stemStats) == 0)
            stemChecker = imopen(~tempImg, strel(<span class="string">'line'</span>, <span class="keyword">...</span>
                1.75*spaceHeight, 90));
            stemStats = regionprops(stemChecker);
        <span class="keyword">end</span>

        <span class="comment">%--------------------------------------------------------</span>
        <span class="comment">% Notehead detection: Section step to determine note type</span>
        <span class="comment">% - One or more: (quarter-64th) notes</span>
        <span class="comment">% - Zero: whole/half notes</span>
        <span class="comment">%--------------------------------------------------------</span>
        <span class="comment">% Because of the notehead's geometry, the structuring element</span>
        <span class="comment">% used is a line of length (spaceHeight), angled at 30 degrees</span>
        noteHead = imerode(~tempImg, strel(<span class="string">'line'</span>, <span class="keyword">...</span>
            spaceHeight, 30));
        <span class="comment">% Detected noteheads are enhanced in order to be counted properly</span>
        <span class="comment">% *Second condition is added as a failsafe for smaller sheets</span>
        <span class="keyword">if</span> (spaceHeight &gt; 10)
            noteHead = imopen(noteHead, strel(<span class="string">'disk'</span>, 3));
        <span class="keyword">else</span>
            noteHead = imopen(noteHead, strel(<span class="string">'disk'</span>, 2));
        <span class="keyword">end</span>
        cc = bwconncomp(noteHead);
        noteHeadStats = regionprops(noteHead, <span class="string">'BoundingBox'</span>, <span class="string">'Area'</span>);
        <span class="comment">% If side-adjacent notes are present, they have to be broken</span>
        <span class="comment">% further for correct detection</span>
        idx = find([noteHeadStats.Area] &gt; 8*spaceHeight);
        <span class="comment">% Isolate the partially detected notes</span>
        tempImg2 = ismember(labelmatrix(cc), idx);
        <span class="comment">% Remove isolated component from complete notehead image</span>
        noteHead = xor(noteHead, ismember(labelmatrix(cc), idx));

        <span class="comment">% Adjacent note segmentation</span>
        <span class="keyword">if</span> (~isequal(tempImg2, zeros(size(noteHead))))
            <span class="comment">% The stem is extended horizontally and vertically</span>
            stemExt = imdilate(stemChecker, strel(<span class="string">'line'</span>, 2*lineHeight,<span class="keyword">...</span>
                90));
            stemExt = imdilate(stemExt, strel(<span class="string">'line'</span>, floor(0.5*<span class="keyword">...</span>
                spaceHeight), 0));
            <span class="comment">% By extending the stems, it ensures complete separation</span>
            <span class="comment">% between connected noteheads</span>
            tempImg2 = or(~tempImg2, stemExt);
            noteHead = or(noteHead, ~tempImg2);
            noteHeadStats = regionprops(noteHead, <span class="string">'BoundingBox'</span>);
        <span class="keyword">end</span>

        <span class="comment">%--------------------------------------------------------</span>
        <span class="comment">% Non-whole single note detection</span>
        <span class="comment">%--------------------------------------------------------</span>
        <span class="keyword">if</span> ((z(3) &gt; spaceHeight &amp;&amp; z(4) &gt;= 2*spaceHeight))
            <span class="comment">%--------------------------------------------------------</span>
            <span class="comment">% Closed note detection: quarter-64th notes</span>
            <span class="comment">%--------------------------------------------------------</span>
            <span class="keyword">if</span> (numel(stemStats) == 1)
                <span class="comment">% If noteheads are detected, potential note falls on</span>
                <span class="comment">% (quarter-64)</span>
                <span class="keyword">if</span> (numel(noteHeadStats) ~= 0)
                    <span class="comment">% Isolate the detected noteheads for counting</span>
                    unbeamedNoteHeads(boxHeight, boxWidth) = ~noteHead(<span class="keyword">...</span>
                        boxHeight, boxWidth);
                    <span class="comment">% Increase the size of noteheads</span>
                    noteHead2 = imdilate(noteHead, strel(<span class="string">'disk'</span>, floor(<span class="keyword">...</span>
                        spaceHeight*0.3)));
                    <span class="comment">%--------------------------------------------------</span>
                    <span class="comment">% Flag detection: Because of its geometry, once the</span>
                    <span class="comment">%     noteheads are removed, flags are detected w/</span>
                    <span class="comment">%     a structuring element with length 1.25x of</span>
                    <span class="comment">%     staff spaceheight, leaning at an angle of -45</span>
                    <span class="comment">%     degrees</span>
                    <span class="comment">%--------------------------------------------------</span>
                    filled1 = imopen(xor(~noteHead2, tempImg), strel(<span class="keyword">...</span>
                        <span class="string">'line'</span>, floor(spaceHeight*1.25), -45));
                    cc1 = bwconncomp(filled1);
                    <span class="comment">% Returns the total number of flags detected</span>
                    flagCount = numel(regionprops(cc1));
                    <span class="comment">% If there are no flags detected initially, it is</span>
                    <span class="comment">% possible that the note is upside down</span>
                    <span class="keyword">if</span>(flagCount == 0)
                        <span class="comment">% With an upside down note, the flags are angled</span>
                        <span class="comment">% at 45 degrees</span>
                        filled2 = imopen(xor(~noteHead2, tempImg), <span class="keyword">...</span>
                            strel(<span class="string">'line'</span>, floor(spaceHeight*1.25), 45));
                        cc2 = bwconncomp(filled2);
                        <span class="comment">% Returns the total number of flags detected</span>
                        flagCount = numel(regionprops(cc2));
                    <span class="keyword">end</span>
                    <span class="comment">% Determine the note type based on flag count</span>
                    <span class="keyword">if</span> (flagCount &gt;= 0 &amp;&amp; flagCount &lt;= 4)
                        <span class="keyword">if</span> (flagCount == 0)
                            noteType = <span class="string">'quarter'</span>;
                            noteVal = 0.25;
                        <span class="keyword">elseif</span> (flagCount == 1)
                            noteType = <span class="string">'8th'</span>;
                            noteVal = 0.125;
                        <span class="keyword">elseif</span> (flagCount == 2)
                            noteType = <span class="string">'16th'</span>;
                            noteVal = 0.0625;
                        <span class="keyword">elseif</span> (flagCount == 3)
                            noteType = <span class="string">'32nd'</span>;
                            noteVal = 0.03125;
                        <span class="keyword">elseif</span> (flagCount == 4)
                            noteType = <span class="string">'64th'</span>;
                            noteVal = 0.015625;
                        <span class="keyword">end</span>
                        <span class="comment">% Count the number of noteheads detected in</span>
                        <span class="comment">% the isolated note/chord</span>
                        cc2 = bwconncomp(~unbeamedNoteHeads);
                        singleNote = regionprops(cc2, <span class="string">'BoundingBox'</span>);
                        <span class="keyword">for</span> ii = 1:numel(singleNote)
                            <span class="comment">% Every notehead's boundaries are extracted</span>
                            z2 = noteHeadStats(ii).BoundingBox;
                            h2 = ceil(z2(2))+z2(4);
                            w2 = ceil(z2(1))+z2(3);
                            boxHeight2 = ceil(z2(2)):h2-1;
                            boxWidth2 = ceil(z2(1)):w2-1;

                            <span class="comment">% Each notehead's parameters are saved</span>
                            chordNote = ismember(labelmatrix(cc2),ii);
                            symbol{symCount} = ~chordNote(boxHeight2, <span class="keyword">...</span>
                                boxWidth2);
                            loc(symCount) = {[ceil(z2(2)) h2-1 ceil(<span class="keyword">...</span>
                                z2(1)) w2-1]};
                            category(symCount) = {<span class="string">'note'</span>};
                            type(symCount) = {noteType};
                            value(symCount) = {noteVal};
                            symIdx(symCount) = {ceil(z2(1))};
                            symCount = symCount + 1;
                            <span class="keyword">if</span> (debug == 1)
                                rectangle(<span class="string">'Position'</span>,noteHeadStats(<span class="keyword">...</span>
                                ii).BoundingBox, <span class="string">'EdgeColor'</span>,<span class="keyword">...</span>
                                <span class="string">'#EDB120'</span>, <span class="string">'LineWidth'</span>,2);
                            <span class="keyword">end</span>
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="comment">%--------------------------------------------------------</span>
                <span class="comment">% Half note detection: Detection based on holes</span>
                <span class="comment">%--------------------------------------------------------</span>
                <span class="keyword">else</span>
                    <span class="comment">% Returns the number of holes detected in the note or</span>
                    <span class="comment">% chord</span>
                    [~, cc, holeStats] = detectOpenNoteheads(tempImg,<span class="keyword">...</span>
                        spaceHeight);

                    <span class="keyword">for</span> ii = 1:numel(holeStats)
                        <span class="comment">% Every note hole's boundaries are extracted</span>
                        z2 = holeStats(ii).BoundingBox;
                        h2 = ceil(z2(2))+z2(4);
                        w2 = ceil(z2(1))+z2(3);
                        boxHeight2 = ceil(z2(2)):h2;
                        boxWidth2 = ceil(z2(1)):w2;

                        <span class="comment">% Each note hole's parameters are saved</span>
                        singleHole = ismember(labelmatrix(cc),ii);
                        symbol{symCount} = ~singleHole(boxHeight2, <span class="keyword">...</span>
                            boxWidth2);
                        loc(symCount) = {[ceil(z2(2)) h2 ceil(z2(1)) <span class="keyword">...</span>
                            w2]};
                        category(symCount) = {<span class="string">'note'</span>};
                        type(symCount) = {<span class="string">'half'</span>};
                        value(symCount) = {0.5};
                        symIdx(symCount) = {ceil(z2(1))};
                        symCount = symCount + 1;
                        <span class="keyword">if</span> (debug == 1)
                            rectangle(<span class="string">'Position'</span>,holeStats(ii). <span class="keyword">...</span>
                                BoundingBox, <span class="string">'EdgeColor'</span>,<span class="string">'#EDB120'</span>, <span class="keyword">...</span>
                                <span class="string">'LineWidth'</span>,2);
                        <span class="keyword">end</span>
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="comment">%--------------------------------------------------------</span>
            <span class="comment">% Whole note chord detection: The detection process is</span>
            <span class="comment">%     similar to half note detection</span>
            <span class="comment">%--------------------------------------------------------</span>
            <span class="keyword">else</span>
                <span class="comment">% Returns the number of holes detected in the chord</span>
                [~, cc, holeStats] = detectOpenNoteheads(tempImg, <span class="keyword">...</span>
                    spaceHeight);
                <span class="keyword">for</span> ii = 1:numel(holeStats)
                    <span class="comment">% Every note hole's boundaries are extracted</span>
                    z2 = holeStats(ii).BoundingBox;
                    h2 = ceil(z2(2))+z2(4);
                    w2 = ceil(z2(1))+z2(3);
                    boxHeight2 = ceil(z2(2)):h2;
                    boxWidth2 = ceil(z2(1)):w2;

                    <span class="comment">% Each note hole's parameters are saved</span>
                    singleHole = ismember(labelmatrix(cc),ii);
                    symbol{symCount} = ~singleHole(boxHeight2, boxWidth2);
                    loc(symCount) = {[ceil(z2(2)) h2 ceil(z2(1)) w2]};
                    category(symCount) = {<span class="string">'note'</span>};
                    type(symCount) = {<span class="string">'whole'</span>};
                    value(symCount) = {1};
                        symIdx(symCount) = {ceil(z2(1))};
                    symCount = symCount + 1;
                    <span class="keyword">if</span> (debug == 1)
                        rectangle(<span class="string">'Position'</span>,holeStats(ii).BoundingBox, <span class="keyword">...</span>
                            <span class="string">'EdgeColor'</span>,<span class="string">'#EDB120'</span>, <span class="string">'LineWidth'</span>,2);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="comment">%--------------------------------------------------------</span>
        <span class="comment">% Single whole note detection: The only note type that</span>
        <span class="comment">%     undergoes template matching to distinguish it from</span>
        <span class="comment">%     non-note symbols that might have been included in</span>
        <span class="comment">%     the section</span>
        <span class="comment">%--------------------------------------------------------</span>
        <span class="keyword">else</span>
            <span class="comment">% Detects the number of holes, which in this case, just 1</span>
            [wholeNoteHole, ~, holeStats] = detectOpenNoteheads(<span class="keyword">...</span>
                tempImg, spaceHeight);
            <span class="comment">% Isolate whole note</span>
            symTmp = section(boxHeight, boxWidth);
            corr_val = [];
            <span class="comment">% 2-D correlation template matching with whole note dataset</span>
            <span class="keyword">for</span> jj = 1:length(wholeNotes)
                whole = imresize(wholeNotes{jj},[length(boxHeight), <span class="keyword">...</span>
                    length(boxWidth)]);
                corr_val = [corr_val corr2(symTmp, whole)];
            <span class="keyword">end</span>
            <span class="comment">% If the maximum correlation coefficient is &gt;= 0.5, note</span>
            <span class="comment">% parameters are saved</span>
            [corrPct, idx] = max(corr_val);
            <span class="keyword">if</span> (corrPct &gt;= 0.5)
                <span class="comment">% For phase 3 assignment, the note hole bounds will be</span>
                <span class="comment">% extracted</span>
                z2 = holeStats(1).BoundingBox;
                h2 = ceil(z2(2))+z2(4);
                w2 = ceil(z2(1))+z2(3);
                boxHeight2 = ceil(z2(2)):h2;
                boxWidth2 = ceil(z2(1)):w2;

                <span class="comment">% Each note hole's parameters are saved</span>
                symbol{symCount} = ~wholeNoteHole(boxHeight2, boxWidth2);
                loc(symCount) = {[ceil(z2(2)) h2 ceil(z2(1)) w2]};
                category(symCount) = wholeNotes(idx,2);
                type(symCount) = wholeNotes(idx,3);
                value(symCount) = wholeNotes(idx,4);
                symIdx(symCount) = {ceil(z2(1))};
                symCount = symCount + 1;
                <span class="keyword">if</span> (debug == 1)
                    rectangle(<span class="string">'Position'</span>,holeStats(1).BoundingBox, <span class="keyword">...</span>
                        <span class="string">'EdgeColor'</span>,<span class="string">'#EDB120'</span>, <span class="string">'LineWidth'</span>,2);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>
    <span class="keyword">end</span>

    <span class="comment">% Combine parameters for complete unbeamed note definitions</span>
    unbeamedNotes = [symbol', loc', category', type', value', symIdx'];
<span class="keyword">end</span>
</pre><pre class="codeoutput error">Not enough input arguments.

Error in detectUnbeamedNotes (line 13)
    ledgerLines = imclose(section, strel('rectangle', ...
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
% Function name:    detectUnbeamedNotes
% Input arg(s):     unbeamed section, staff space/line heights, whole
%                   note dataset
% Outputs arg(s):   unbeamed notes and ledger line locations
% Description:      Detects single and chord unbeamed notes from whole
%                   to 64th
%REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH-
function [unbeamedNotes, ledgerLineLocs] = detectUnbeamedNotes(...
    section, spaceHeight, lineHeight, wholeNotes, debug)

    % Extract ledger lines for subsequent pitch assignment
    ledgerLines = imclose(section, strel('rectangle', ...
        [2, floor(spaceHeight * 2)]));
    cc = bwconncomp(~ledgerLines);
    stats = regionprops(cc, 'Area');
    % Ensures that only ledger lines are being removed and not segments
    % of adjacent notes
    idx = find([stats.Area] <= 12*spaceHeight);
    ledgerLines = ismember(labelmatrix(cc), idx);
    % Extends the ledger lines for location calculation
    lineExt = imdilate(ledgerLines, strel('line', ...
        2*size(section,2), 0));
    ledgerLineLocs = find(sum(lineExt, 2) ~= 0);

    % If ledger lines exist in the section, they are to be removed before
    % detection
    if(~isempty(ledgerLineLocs))
        section = ledgerRemove(section, ledgerLineLocs);
    end

    symbol = {};
    loc = {};
    category = {};
    type = {};
    value = {};
    symIdx = {};
    symCount = 1;

    % Perform a small opening to ensure that note edges are connected
    section = imopen(section, strel('line', 3, 0));
    noteStats = regionprops(~section, 'BoundingBox');  
    % Examine individual component
    for i = 1:numel(noteStats)
        % Extract component boundaries
        tempImg = ones(size(section));
        unbeamedNoteHeads = ones(size(section));
        z = noteStats(i).BoundingBox;
        h = ceil(z(2))+z(4);
        w = ceil(z(1))+z(3);
        boxHeight = ceil(z(2)):h-1;
        boxWidth = ceil(z(1)):w-1;
        % Copy note in temporary holder
        tempImg(boxHeight, boxWidth) = section(boxHeight, boxWidth);
%         imshow(tempImg); pause;
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Stem detection: Determines if the symbol is either:
        % - (half-64th) note/chord         - whole note chords
        % - single whole notes
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Checks for (half-64th) notes/chords:
        stemChecker = imerode(~tempImg, strel('line', ...
            (3*spaceHeight + 2*lineHeight), 90));
        stemChecker = imdilate(stemChecker, strel('line', ...
            (3*spaceHeight + 2*lineHeight), 90));
        stemStats = regionprops(stemChecker);
        % Checks for (half-64th) chords that were missed by first check:
        if (numel(stemStats) > 1)
            stemChecker = imopen(stemChecker, strel('line', ...
                4.25*spaceHeight, 90));
            stemStats = regionprops(stemChecker);
        % Checks for whole notes/chords:
        elseif (numel(stemStats) == 0)
            stemChecker = imopen(~tempImg, strel('line', ...
                1.75*spaceHeight, 90));
            stemStats = regionprops(stemChecker);
        end
        
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Notehead detection: Section step to determine note type
        % - One or more: (quarter-64th) notes
        % - Zero: whole/half notes
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Because of the notehead's geometry, the structuring element
        % used is a line of length (spaceHeight), angled at 30 degrees
        noteHead = imerode(~tempImg, strel('line', ...
            spaceHeight, 30));
        % Detected noteheads are enhanced in order to be counted properly
        % *Second condition is added as a failsafe for smaller sheets
        if (spaceHeight > 10)
            noteHead = imopen(noteHead, strel('disk', 3));
        else            
            noteHead = imopen(noteHead, strel('disk', 2));           
        end
        cc = bwconncomp(noteHead);
        noteHeadStats = regionprops(noteHead, 'BoundingBox', 'Area');
        % If side-adjacent notes are present, they have to be broken 
        % further for correct detection
        idx = find([noteHeadStats.Area] > 8*spaceHeight);
        % Isolate the partially detected notes
        tempImg2 = ismember(labelmatrix(cc), idx);
        % Remove isolated component from complete notehead image
        noteHead = xor(noteHead, ismember(labelmatrix(cc), idx));

        % Adjacent note segmentation
        if (~isequal(tempImg2, zeros(size(noteHead))))
            % The stem is extended horizontally and vertically
            stemExt = imdilate(stemChecker, strel('line', 2*lineHeight,...
                90));
            stemExt = imdilate(stemExt, strel('line', floor(0.5*...
                spaceHeight), 0));
            % By extending the stems, it ensures complete separation
            % between connected noteheads
            tempImg2 = or(~tempImg2, stemExt);
            noteHead = or(noteHead, ~tempImg2); 
            noteHeadStats = regionprops(noteHead, 'BoundingBox');
        end
        
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Non-whole single note detection
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        if ((z(3) > spaceHeight && z(4) >= 2*spaceHeight))
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Closed note detection: quarter-64th notes
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            if (numel(stemStats) == 1) 
                % If noteheads are detected, potential note falls on
                % (quarter-64)
                if (numel(noteHeadStats) ~= 0)
                    % Isolate the detected noteheads for counting
                    unbeamedNoteHeads(boxHeight, boxWidth) = ~noteHead(...
                        boxHeight, boxWidth);
                    % Increase the size of noteheads
                    noteHead2 = imdilate(noteHead, strel('disk', floor(...
                        spaceHeight*0.3)));
                    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                    % Flag detection: Because of its geometry, once the 
                    %     noteheads are removed, flags are detected w/ 
                    %     a structuring element with length 1.25x of 
                    %     staff spaceheight, leaning at an angle of -45 
                    %     degrees
                    %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                    filled1 = imopen(xor(~noteHead2, tempImg), strel(...
                        'line', floor(spaceHeight*1.25), -45));
                    cc1 = bwconncomp(filled1);
                    % Returns the total number of flags detected 
                    flagCount = numel(regionprops(cc1));
                    % If there are no flags detected initially, it is 
                    % possible that the note is upside down
                    if(flagCount == 0)
                        % With an upside down note, the flags are angled
                        % at 45 degrees
                        filled2 = imopen(xor(~noteHead2, tempImg), ...
                            strel('line', floor(spaceHeight*1.25), 45));
                        cc2 = bwconncomp(filled2);
                        % Returns the total number of flags detected 
                        flagCount = numel(regionprops(cc2));
                    end
                    % Determine the note type based on flag count
                    if (flagCount >= 0 && flagCount <= 4)
                        if (flagCount == 0)
                            noteType = 'quarter';
                            noteVal = 0.25;
                        elseif (flagCount == 1)
                            noteType = '8th';
                            noteVal = 0.125;
                        elseif (flagCount == 2)
                            noteType = '16th';
                            noteVal = 0.0625;
                        elseif (flagCount == 3)
                            noteType = '32nd';
                            noteVal = 0.03125;
                        elseif (flagCount == 4)
                            noteType = '64th';
                            noteVal = 0.015625;         
                        end
                        % Count the number of noteheads detected in
                        % the isolated note/chord
                        cc2 = bwconncomp(~unbeamedNoteHeads);
                        singleNote = regionprops(cc2, 'BoundingBox');
                        for ii = 1:numel(singleNote)
                            % Every notehead's boundaries are extracted
                            z2 = noteHeadStats(ii).BoundingBox;
                            h2 = ceil(z2(2))+z2(4);
                            w2 = ceil(z2(1))+z2(3);
                            boxHeight2 = ceil(z2(2)):h2-1;
                            boxWidth2 = ceil(z2(1)):w2-1;
                            
                            % Each notehead's parameters are saved
                            chordNote = ismember(labelmatrix(cc2),ii);
                            symbol{symCount} = ~chordNote(boxHeight2, ...
                                boxWidth2);
                            loc(symCount) = {[ceil(z2(2)) h2-1 ceil(...
                                z2(1)) w2-1]};
                            category(symCount) = {'note'};
                            type(symCount) = {noteType};
                            value(symCount) = {noteVal};
                            symIdx(symCount) = {ceil(z2(1))};
                            symCount = symCount + 1;   
                            if (debug == 1)
                                rectangle('Position',noteHeadStats(...
                                ii).BoundingBox, 'EdgeColor',...
                                '#EDB120', 'LineWidth',2);
                            end
                        end
                    end
                %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                % Half note detection: Detection based on holes
                %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
                else
                    % Returns the number of holes detected in the note or
                    % chord
                    [~, cc, holeStats] = detectOpenNoteheads(tempImg,...
                        spaceHeight);
                    
                    for ii = 1:numel(holeStats)
                        % Every note hole's boundaries are extracted
                        z2 = holeStats(ii).BoundingBox;
                        h2 = ceil(z2(2))+z2(4);
                        w2 = ceil(z2(1))+z2(3);
                        boxHeight2 = ceil(z2(2)):h2;
                        boxWidth2 = ceil(z2(1)):w2;    
                        
                        % Each note hole's parameters are saved
                        singleHole = ismember(labelmatrix(cc),ii);
                        symbol{symCount} = ~singleHole(boxHeight2, ...
                            boxWidth2);
                        loc(symCount) = {[ceil(z2(2)) h2 ceil(z2(1)) ...
                            w2]};
                        category(symCount) = {'note'};
                        type(symCount) = {'half'};
                        value(symCount) = {0.5};
                        symIdx(symCount) = {ceil(z2(1))};
                        symCount = symCount + 1;
                        if (debug == 1)
                            rectangle('Position',holeStats(ii). ...
                                BoundingBox, 'EdgeColor','#EDB120', ...
                                'LineWidth',2);
                        end
                    end
                end
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            % Whole note chord detection: The detection process is 
            %     similar to half note detection
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            else
                % Returns the number of holes detected in the chord
                [~, cc, holeStats] = detectOpenNoteheads(tempImg, ...
                    spaceHeight); 
                for ii = 1:numel(holeStats)
                    % Every note hole's boundaries are extracted
                    z2 = holeStats(ii).BoundingBox;
                    h2 = ceil(z2(2))+z2(4);
                    w2 = ceil(z2(1))+z2(3);
                    boxHeight2 = ceil(z2(2)):h2;
                    boxWidth2 = ceil(z2(1)):w2;                        

                    % Each note hole's parameters are saved
                    singleHole = ismember(labelmatrix(cc),ii);
                    symbol{symCount} = ~singleHole(boxHeight2, boxWidth2);
                    loc(symCount) = {[ceil(z2(2)) h2 ceil(z2(1)) w2]};
                    category(symCount) = {'note'};
                    type(symCount) = {'whole'};
                    value(symCount) = {1};
                        symIdx(symCount) = {ceil(z2(1))};
                    symCount = symCount + 1;   
                    if (debug == 1)
                        rectangle('Position',holeStats(ii).BoundingBox, ...
                            'EdgeColor','#EDB120', 'LineWidth',2);
                    end
                end
            end
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        % Single whole note detection: The only note type that 
        %     undergoes template matching to distinguish it from 
        %     non-note symbols that might have been included in 
        %     the section
        %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
        else
            % Detects the number of holes, which in this case, just 1
            [wholeNoteHole, ~, holeStats] = detectOpenNoteheads(...
                tempImg, spaceHeight); 
            % Isolate whole note
            symTmp = section(boxHeight, boxWidth);
            corr_val = [];
            % 2-D correlation template matching with whole note dataset
            for jj = 1:length(wholeNotes)
                whole = imresize(wholeNotes{jj},[length(boxHeight), ...
                    length(boxWidth)]);
                corr_val = [corr_val corr2(symTmp, whole)];
            end
            % If the maximum correlation coefficient is >= 0.5, note
            % parameters are saved            
            [corrPct, idx] = max(corr_val);
            if (corrPct >= 0.5)
                % For phase 3 assignment, the note hole bounds will be 
                % extracted
                z2 = holeStats(1).BoundingBox;
                h2 = ceil(z2(2))+z2(4);
                w2 = ceil(z2(1))+z2(3);
                boxHeight2 = ceil(z2(2)):h2;
                boxWidth2 = ceil(z2(1)):w2;                        

                % Each note hole's parameters are saved
                symbol{symCount} = ~wholeNoteHole(boxHeight2, boxWidth2);
                loc(symCount) = {[ceil(z2(2)) h2 ceil(z2(1)) w2]};
                category(symCount) = wholeNotes(idx,2);
                type(symCount) = wholeNotes(idx,3);
                value(symCount) = wholeNotes(idx,4);
                symIdx(symCount) = {ceil(z2(1))};
                symCount = symCount + 1;    
                if (debug == 1)
                    rectangle('Position',holeStats(1).BoundingBox, ...
                        'EdgeColor','#EDB120', 'LineWidth',2);
                end
            end
        end
    end
    
    % Combine parameters for complete unbeamed note definitions
    unbeamedNotes = [symbol', loc', category', type', value', symIdx'];
end
##### SOURCE END #####
--></body></html>