
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>audio</title><meta name="generator" content="MATLAB 9.9"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2021-04-02"><meta name="DC.source" content="audio.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><pre class="codeinput">/*************************************************************************
 * File name:		audio.c
 * Description:		Function definitions <span class="string">for</span> <span class="string">audio</span> <span class="string">configuration</span> <span class="string">and</span>
 *					music generation
 *************************************************************************/
#include <span class="string">"intc_handler.h"</span>
#include <span class="string">"audio.h"</span>

//----------------------------------------------------
// Variable definitions
//----------------------------------------------------
u32 <span class="string">*(baseaddr_mus)</span> <span class="string">=</span> <span class="string">(u32 *)XPAR_ORGANSYNTH_0_S00_AXI_BASEADDR</span>;
int <span class="string">temp</span> <span class="string">=</span> <span class="string">0</span>;
int <span class="string">volume</span>;
static <span class="string">bool</span> <span class="string">done</span> <span class="string">=</span> <span class="string">false</span>;

//----------------------------------------------------
// I2C CONFIGURATION <span class="string">FUNCTION</span>
// - Initializes the <span class="string">I2C</span> <span class="string">driver</span> <span class="string">and</span> <span class="string">sets</span> <span class="string">the</span> <span class="string">I2C</span>
//   serial clock <span class="string">rate</span>
//----------------------------------------------------
unsigned <span class="string">char</span> <span class="string">IicConfig(unsigned int DeviceIdPS)</span>
{
	XIicPs_Config *Config;
	int Status;

	// Look up the configuration in the config table
	Config = XIicPs_LookupConfig(DeviceIdPS);
	<span class="keyword">if</span>(NULL == Config) {
		<span class="keyword">return</span> XST_FAILURE;
	}

	// Initialize the <span class="string">IIC</span> <span class="string">driver</span> <span class="string">configuration</span>
	Status = XIicPs_CfgInitialize(&amp;Iic, Config, Config-&gt;BaseAddress);
	<span class="keyword">if</span>(Status != XST_SUCCESS) {
		<span class="keyword">return</span> XST_FAILURE;
	}

	// Perform a <span class="string">self-test</span> <span class="string">to</span> <span class="string">ensure</span> <span class="string">that</span> <span class="string">the</span> <span class="string">hardware</span> <span class="string">functions</span>
	// correctly.
	Status = XIicPs_SelfTest(&amp;Iic);
	<span class="keyword">if</span> (Status != XST_SUCCESS) {
		xil_printf(<span class="string">"IIC FAILED \r\n"</span>);
		<span class="keyword">return</span> XST_FAILURE;
	}
	xil_printf(<span class="string">"IIC Passed\r\n"</span>);

	// Set the <span class="string">IIC</span> <span class="string">serial</span> <span class="string">clock</span> <span class="string">rate.</span>
	Status = XIicPs_SetSClk(&amp;Iic, IIC_SCLK_RATE);
	<span class="keyword">if</span> (Status != XST_SUCCESS) {
		<span class="keyword">return</span> XST_FAILURE;
	}

	<span class="keyword">return</span> XST_SUCCESS;
}

//----------------------------------------------------
// AUDIO PLL <span class="string">CONFIGURATION</span> <span class="string">FUNCTION</span>
// - Performs various <span class="string">functions</span> <span class="string">such</span> <span class="string">as</span> <span class="string">resetting</span>
//   codec software, setting <span class="string">ADC/DAC</span> <span class="string">volumes</span>, and
//   setting sampling <span class="string">rate</span> <span class="string">at</span> <span class="string">48kHz</span>
//----------------------------------------------------
void <span class="string">AudioPllConfig()</span> <span class="string">{</span>

	// Perform Reset
	AudioWriteToReg(R15_SOFTWARE_RESET,                 0b000000000);
	usleep(75000);
	// Power Up
	AudioWriteToReg(R6_POWER_MANAGEMENT,                0b000110000);
	// Default Volume
	AudioWriteToReg(R0_LEFT_CHANNEL_ADC_INPUT_VOLUME,   0b000011111);
	// Default Volume
	AudioWriteToReg(R1_RIGHT_CHANNEL_ADC_INPUT_VOLUME,  0b000011111);
	AudioWriteToReg(R2_LEFT_CHANNEL_DAC_VOLUME,         0b101111111);
	AudioWriteToReg(R3_RIGHT_CHANNEL_DAC_VOLUME,        0b101111111);
	// Allow Mixed <span class="string">DAC</span>, Mute <span class="string">MIC</span>
	AudioWriteToReg(R4_ANALOG_AUDIO_PATH,               0b000010010);
	// 48 kHz <span class="string">Sampling</span> <span class="string">Rate</span> <span class="string">emphasis</span>, no <span class="string">high</span> <span class="string">pass</span>
	AudioWriteToReg(R5_DIGITAL_AUDIO_PATH,              0b000000110);
	// I2S Mode, set-up 32 bits
	AudioWriteToReg(R7_DIGITAL_AUDIO_I_F,               0b000001010);
	AudioWriteToReg(R8_SAMPLING_RATE,                   0b000000000);
	usleep(75000);
	// Activate digital <span class="string">core</span>
	AudioWriteToReg(R9_ACTIVE,                          0b000000001);
	// Output Power <span class="string">Up</span>
	AudioWriteToReg(R6_POWER_MANAGEMENT,                0b000100010);
}


//----------------------------------------------------
// REGISTER WRITE <span class="string">FUNCTION</span>
// - Allows writing <span class="string">to</span> <span class="string">one</span> <span class="string">of</span> <span class="string">the</span> <span class="string">audio</span> <span class="untermstring">controller's</span>
//	 registers
//----------------------------------------------------
void <span class="string">AudioWriteToReg(u8 u8RegAddr, u16 u16Data)</span> <span class="string">{</span>

	unsigned <span class="string">char</span> <span class="string">u8TxData[2]</span>;

	u8TxData[0] = u8RegAddr &lt;&lt; 1;
	u8TxData[0] = u8TxData[0] | ((u16Data &gt;&gt; 8) &amp; 0b1);

	u8TxData[1] = u16Data &amp; 0xFF;

	XIicPs_MasterSendPolled(&amp;Iic, u8TxData, 2, IIC_SLAVE_ADDR);
	<span class="keyword">while</span>(XIicPs_BusIsBusy(&amp;Iic));
}


//----------------------------------------------------
// AUDIO GENERATION <span class="string">FUNCTION</span>
// - Receives notes <span class="string">and</span> <span class="string">beats</span> <span class="string">and</span> <span class="string">turn</span> <span class="string">them</span> <span class="string">to</span> <span class="string">audible</span>
//   sounds
//----------------------------------------------------
void <span class="string">HarmonizerPlay(int noteArray[][ARR_LEN], double beatArray[], int tempo,</span>
	int <span class="string">index)</span>
{
	done = false;
	temp = 0;
	u32 out_left, out_right;
	int space = noteArray[index][8];

	// Sends four of the input notes to slave register 0
	*(baseaddr_mus + 0) = 0x00000000 + noteArray[index][0] +
		(noteArray[index][1] &lt;&lt; 8) +
		(noteArray[index][2] &lt;&lt; 16) +
		(noteArray[index][3] &lt;&lt; 24);
	// Sends four of the input notes to slave register 1
	*(baseaddr_mus + 1) = 0x00000000 + noteArray[index][4] +
		(noteArray[index][5] &lt;&lt; 8) +
		(noteArray[index][6] &lt;&lt; 16) +
		(noteArray[index][7] &lt;&lt; 24);

	// Play sound <span class="keyword">for</span> the duration <span class="string">of</span> <span class="string">the</span> <span class="string">beat</span>
	<span class="keyword">while</span> (<span class="syscmd">!done)</span>
	{
		out_left =  (u32)(*(baseaddr_mus + 2));
		out_right =  out_left;

		Xil_Out32(I2S_DATA_TX_L_REG, out_left);
		Xil_Out32(I2S_DATA_TX_R_REG, out_right);

		temp++;

		<span class="keyword">if</span>(temp == (int)(tempo * beatArray[index]))	{
			// If note <span class="string">break</span> <span class="string">is</span> <span class="string">1</span>, add <span class="string">a</span> <span class="string">little</span> <span class="string">space</span> <span class="string">in</span> <span class="string">between</span>
			// plays
			<span class="keyword">if</span> (space == 1) {
				*(baseaddr_mus + 0) = 0x00000000;
				*(baseaddr_mus + 1) = 0x00000000;
				<span class="keyword">for</span>(int i = 0; i &lt; (space * 225000); i++);
			}
			<span class="keyword">else</span> {
				*(baseaddr_mus + 0) = *(baseaddr_mus + 0);
				*(baseaddr_mus + 1) = *(baseaddr_mus + 1);
				<span class="keyword">for</span>(int i = 0; i &lt; 1; i++);
			}
			done = true;
		}
	}
	<span class="keyword">return</span>;
}
</pre><pre class="codeoutput error">Error using dbstatus
Error: File: C:\Users\tacat\Desktop\Louis\CSUN\Grad\698C\SOC\audio.m Line: 1 Column: 1
Invalid use of operator.
</pre><p class="footer"><br><a href="https://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2020b</a><br></p></div><!--
##### SOURCE BEGIN #####
/*************************************************************************
 * File name:		audio.c
 * Description:		Function definitions for audio configuration and 
 *					music generation
 *************************************************************************/
#include "intc_handler.h"
#include "audio.h"

//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
// Variable definitions
//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
u32 *(baseaddr_mus) = (u32 *)XPAR_ORGANSYNTH_0_S00_AXI_BASEADDR;
int temp = 0;
int volume;
static bool done = false;

//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
// I2C CONFIGURATION FUNCTION
// - Initializes the I2C driver and sets the I2C
//   serial clock rate
//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
unsigned char IicConfig(unsigned int DeviceIdPS)
{
	XIicPs_Config *Config;
	int Status;

	// Look up the configuration in the config table
	Config = XIicPs_LookupConfig(DeviceIdPS);
	if(NULL == Config) {
		return XST_FAILURE;
	}

	// Initialize the IIC driver configuration
	Status = XIicPs_CfgInitialize(&Iic, Config, Config->BaseAddress);
	if(Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	// Perform a self-test to ensure that the hardware functions
	// correctly.
	Status = XIicPs_SelfTest(&Iic);
	if (Status != XST_SUCCESS) {
		xil_printf("IIC FAILED \r\n");
		return XST_FAILURE;
	}
	xil_printf("IIC Passed\r\n");

	// Set the IIC serial clock rate.
	Status = XIicPs_SetSClk(&Iic, IIC_SCLK_RATE);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	return XST_SUCCESS;
}

//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
// AUDIO PLL CONFIGURATION FUNCTION
// - Performs various functions such as resetting 
//   codec software, setting ADC/DAC volumes, and 
//   setting sampling rate at 48kHz
//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
void AudioPllConfig() {

	// Perform Reset
	AudioWriteToReg(R15_SOFTWARE_RESET,                 0b000000000); 
	usleep(75000);
	// Power Up
	AudioWriteToReg(R6_POWER_MANAGEMENT,                0b000110000); 
	// Default Volume
	AudioWriteToReg(R0_LEFT_CHANNEL_ADC_INPUT_VOLUME,   0b000011111);
	// Default Volume
	AudioWriteToReg(R1_RIGHT_CHANNEL_ADC_INPUT_VOLUME,  0b000011111);	
	AudioWriteToReg(R2_LEFT_CHANNEL_DAC_VOLUME,         0b101111111);
	AudioWriteToReg(R3_RIGHT_CHANNEL_DAC_VOLUME,        0b101111111);
	// Allow Mixed DAC, Mute MIC
	AudioWriteToReg(R4_ANALOG_AUDIO_PATH,               0b000010010); 
	// 48 kHz Sampling Rate emphasis, no high pass
	AudioWriteToReg(R5_DIGITAL_AUDIO_PATH,              0b000000110); 
	// I2S Mode, set-up 32 bits
	AudioWriteToReg(R7_DIGITAL_AUDIO_I_F,               0b000001010); 
	AudioWriteToReg(R8_SAMPLING_RATE,                   0b000000000);
	usleep(75000);
	// Activate digital core
	AudioWriteToReg(R9_ACTIVE,                          0b000000001); 
	// Output Power Up
	AudioWriteToReg(R6_POWER_MANAGEMENT,                0b000100010); 
}


//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
// REGISTER WRITE FUNCTION
// - Allows writing to one of the audio controller's
//	 registers
//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
void AudioWriteToReg(u8 u8RegAddr, u16 u16Data) {

	unsigned char u8TxData[2];

	u8TxData[0] = u8RegAddr << 1;
	u8TxData[0] = u8TxData[0] | ((u16Data >> 8) & 0b1);

	u8TxData[1] = u16Data & 0xFF;

	XIicPs_MasterSendPolled(&Iic, u8TxData, 2, IIC_SLAVE_ADDR);
	while(XIicPs_BusIsBusy(&Iic));
}


//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
// AUDIO GENERATION FUNCTION
// - Receives notes and beats and turn them to audible
//   sounds
//REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
void HarmonizerPlay(int noteArray[][ARR_LEN], double beatArray[], int tempo, 
	int index)
{
	done = false;
	temp = 0;
	u32 out_left, out_right;
	int space = noteArray[index][8];

	// Sends four of the input notes to slave register 0
	*(baseaddr_mus + 0) = 0x00000000 + noteArray[index][0] +
		(noteArray[index][1] << 8) +
		(noteArray[index][2] << 16) +
		(noteArray[index][3] << 24);
	// Sends four of the input notes to slave register 1
	*(baseaddr_mus + 1) = 0x00000000 + noteArray[index][4] +
		(noteArray[index][5] << 8) +
		(noteArray[index][6] << 16) +
		(noteArray[index][7] << 24);

	// Play sound for the duration of the beat
	while (!done)
	{
		out_left =  (u32)(*(baseaddr_mus + 2));
		out_right =  out_left;

		Xil_Out32(I2S_DATA_TX_L_REG, out_left);
		Xil_Out32(I2S_DATA_TX_R_REG, out_right);

		temp++;

		if(temp == (int)(tempo * beatArray[index]))	{
			// If note break is 1, add a little space in between
			// plays
			if (space == 1) {
				*(baseaddr_mus + 0) = 0x00000000;
				*(baseaddr_mus + 1) = 0x00000000;
				for(int i = 0; i < (space * 225000); i++);
			}
			else {
				*(baseaddr_mus + 0) = *(baseaddr_mus + 0);
				*(baseaddr_mus + 1) = *(baseaddr_mus + 1);
				for(int i = 0; i < 1; i++);
			}
			done = true;
		}
	}
	return;
}

##### SOURCE END #####
--></body></html>